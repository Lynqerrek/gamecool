<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hide and Gun</title>
<style>
:root{--bg:#0e1724;--panel:#0f2432;--accent:#ffd166;--accent2:#06d6a0;}
html,body{margin:0;padding:0;height:100%;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#ddd;}
#loading{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;background:var(--bg);z-index:9999;color:#fff;font-weight:700;transition:opacity .45s;}
#loading.fade{opacity:0;pointer-events:none;}
.progress-wrap{width:420px;height:16px;background:rgba(255,255,255,0.06);border-radius:10px;overflow:hidden;}
.progress-bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#ffd966);border-radius:10px;transition:width .15s linear;}
.progress-text{font-size:13px;color:rgba(255,255,255,0.9);margin-top:6px;}
#app{display:grid;grid-template-columns:320px 1fr;gap:12px;height:100vh;padding:12px;box-sizing:border-box;display:none;}
.panel{background:var(--panel);padding:10px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.4);}
#minimap{width:100%;height:calc(100vh - 56px);border-radius:8px;display:block;background:#06111a;}
#gameWrap{display:flex;flex-direction:column;gap:12px;align-items:center;}
#gameCanvas{border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6);background:transparent;display:block;}
.toolbar{display:flex;justify-content:space-between;align-items:center;gap:8px;width:100%;}
button{background:#2b3b4a;color:#fff;border:0;padding:8px 12px;border-radius:6px;cursor:pointer;}
#status{font-size:13px;color:rgba(255,255,255,0.9);}
#staminaBarWrap{width:980px;height:16px;background:rgba(255,255,255,0.06);border-radius:10px;overflow:hidden;}
#staminaBar{height:100%;width:100%;background:linear-gradient(90deg,var(--accent2),#06d6a0);border-radius:10px;transition:width .1s linear;}
footer{position:fixed;right:12px;bottom:12px;color:rgba(255,255,255,0.06);font-size:11px;}
</style>
</head>
<body>
<div id="loading">
  <div style="font-size:54px;letter-spacing:1px;">Hide and Gun</div>
  <div class="small">Loading assets…</div>
  <div class="progress-wrap" aria-hidden="false">
    <div id="progressBar" class="progress-bar"></div>
  </div>
  <div id="progressText" class="progress-text">0%</div>
</div>

<div id="app">
  <div class="panel" style="display:flex;flex-direction:column;gap:10px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small"><strong>Minimap</strong> — shows world & camera view</div>
      <div class="small">Player.png</div>
    </div>
    <canvas id="minimap" width="280" height="800"></canvas>
    <div class="small">Green = tree, Brown = crate, Grey = rock. Player arrow shows facing.</div>
  </div>

  <div id="gameWrap">
    <div class="toolbar panel" style="width:100%">
      <div class="small">WASD to move, Shift to sprint, player faces cursor</div>
      <div style="display:flex;gap:8px">
        <button id="toggleColliders">Show Colliders: Off</button>
        <button id="resetPlayer">Reset</button>
      </div>
    </div>

    <canvas id="gameCanvas" width="980" height="640"></canvas>
    <div id="staminaBarWrap"><div id="staminaBar"></div></div>
    <div class="panel" style="width:100%;max-width:980px">
      <div id="status">Pos: — | FPS: —</div>
    </div>
  </div>
</div>

<footer>Hide and Gun — prototype</footer>

<script>
(() => {
  // CONFIG
  const VIEW_W = 980, VIEW_H = 640;
  const WORLD_W = 2400, WORLD_H = 1600;
  const TILE = 64;
  const SPRINT_MULT = 1.7, STAMINA_MAX = 100, STAMINA_REGEN = 30, STAMINA_DRAIN = 50;

  const clamp = (v,a,b)=>v<a?a:v>b?b:v;
  const now = ()=>performance.now();

  // INPUT
  class Input {
    constructor(){
      this.keys = new Set();
      window.addEventListener('keydown', e=>{
        const k = e.key.toLowerCase();
        if(['w','a','s','d','shift'].includes(k)){ this.keys.add(k); e.preventDefault?.(); }
      }, {passive:false});
      window.addEventListener('keyup', e=>{ this.keys.delete(e.key.toLowerCase()); });
    }
    isDown(k){ return this.keys.has(k); }
  }

  // CAMERA
  class Camera {
    constructor(viewW, viewH, worldW, worldH){ this.viewW=viewW; this.viewH=viewH; this.worldW=worldW; this.worldH=worldH; this.x=viewW/2; this.y=viewH/2; }
    follow(px,py){ const hw=this.viewW/2, hh=this.viewH/2; this.x=clamp(px, hw, this.worldW-hw); this.y=clamp(py, hh, this.worldH-hh);}
    worldToScreen(wx,wy){ return { sx: wx-(this.x-this.viewW/2), sy: wy-(this.y-this.viewH/2) }; }
  }

  // PLAYER
  class Player {
    constructor(x,y,img){
      this.x=x; this.y=y; this.img=img; this.r=18; this.baseSpeed=220; this.angle=0; this.w=48; this.h=48;
      this.stamina = STAMINA_MAX;
    }
    move(dt, input){
      let dx=0, dy=0; const speed = this.baseSpeed * ((input.isDown('shift') && this.stamina>0)?SPRINT_MULT:1);
      if(input.isDown('w')) dy-=1; if(input.isDown('s')) dy+=1; if(input.isDown('a')) dx-=1; if(input.isDown('d')) dx+=1;
      if(dx||dy){ const len=Math.hypot(dx,dy); dx=(dx/len)*speed*dt; dy=(dy/len)*speed*dt; this.x+=dx; this.y+=dy; }
      // stamina
      if(input.isDown('shift') && (dx||dy)) this.stamina-=STAMINA_DRAIN*dt;
      else this.stamina+=STAMINA_REGEN*dt;
      this.stamina=clamp(this.stamina,0,STAMINA_MAX);
    }
    resolveCollisions(objs){ for(let o of objs){ const sx=this.x-o.x, sy=this.y-o.y, dist2=sx*sx+sy*sy, min=this.r+o.r, min2=min*min; if(dist2<min2 && dist2>0.0001){ const dist=Math.sqrt(dist2), overlap=min-dist; const nx=sx/dist, ny=sy/dist; this.x+=nx*overlap; this.y+=ny*overlap;} else if(dist2<=0.0001){ const a=Math.random()*Math.PI*2; this.x+=Math.cos(a)*1; this.y+=Math.sin(a)*1;}}}
    clampToWorld(w,h){ this.x=clamp(this.x,this.r,w-this.r); this.y=clamp(this.y,this.r,h-this.r);}
    draw(ctx, cam, showColliders){
      const p=cam.worldToScreen(this.x,this.y);
      ctx.save(); ctx.translate(p.sx,p.sy); ctx.rotate(this.angle+Math.PI/2);
      if(this.img && this.img.complete) ctx.drawImage(this.img,-this.w/2,-this.h/2,this.w,this.h);
      else { ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.fill();}
      if(showColliders){ ctx.strokeStyle='rgba(255,0,0,0.6)'; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.stroke();}
      ctx.restore();
    }
  }

  class WorldObj {
    constructor(x,y,type){ this.x=x; this.y=y; this.type=type; this.r=(type==='tree')?28:(type==='crate')?20:18;}
    draw(ctx, cam, showCol){
      const p=cam.worldToScreen(this.x,this.y); ctx.save(); ctx.translate(p.sx,p.sy);
      if(this.type==='tree'){ ctx.fillStyle='#6b3e16'; ctx.fillRect(-6,6,12,18); ctx.beginPath(); ctx.fillStyle='#228b22'; ctx.ellipse(0,-2,24,18,0,0,Math.PI*2); ctx.fill(); }
      else if(this.type==='crate'){ ctx.fillStyle='#8b5a2b'; ctx.fillRect(-16,-12,32,24); ctx.strokeStyle='rgba(0,0,0,0.22)'; ctx.strokeRect(-16,-12,32,24); }
      else { ctx.beginPath(); ctx.fillStyle='#9aa0a6'; ctx.ellipse(0,0,18,12,0,0,Math.PI*2); ctx.fill(); }
      if(showCol){ ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.stroke();}
      ctx.restore();
    }
  }

  // DOM
  const loading=document.getElementById('loading'), app=document.getElementById('app');
  const canvas=document.getElementById('gameCanvas'), ctx=canvas.getContext('2d');
  const minimap=document.getElementById('minimap'), mmCtx=minimap.getContext('2d');
  const toggleBtn=document.getElementById('toggleColliders'), resetBtn=document.getElementById('resetPlayer');
  const status=document.getElementById('status'), staminaBar=document.getElementById('staminaBar');
  const dpr=window.devicePixelRatio||1;

  canvas.width=VIEW_W*dpr; canvas.height=VIEW_H*dpr; canvas.style.width=VIEW_W+'px'; canvas.style.height=VIEW_H+'px'; ctx.setTransform(dpr,0,0,dpr,0,0);

  // Minimap sizing
  const mmCssW=280; const mmCssH=Math.min(window.innerHeight-56,800); minimap.width=mmCssW*dpr; minimap.height=mmCssH*dpr; minimap.style.height=mmCssH+'px'; mmCtx.setTransform(dpr,0,0,dpr,0,0);

  // Assets
  const assets=[{type:'image',src:'./Player.png',target:'player'}]; const loaders={}; let playerImg=new Image(); loaders.player=playerImg;

  // Tile background
  const tileCanvas=document.createElement('canvas'); tileCanvas.width=64; tileCanvas.height=64;
  const tctx=tileCanvas.getContext('2d'); tctx.fillStyle='rgba(30,45,65,0.85)'; tctx.fillRect(0,0,64,64); tctx.fillStyle='rgba(28,40,58,0.85)'; tctx.fillRect(0,0,32,32); tctx.fillRect(32,32,32,32);

  const objects=[]; const playerStart={x:WORLD_W/2,y:WORLD_H/2};
  for(let i=0;i<45;i++){ let x,y,tries=0; do{x=Math.random()*WORLD_W;y=Math.random()*WORLD_H;tries++;}while(Math.hypot(x-playerStart.x,y-playerStart.y)<180 && tries<40); objects.push(new WorldObj(x,y,['tree','crate','rock'][Math.floor(Math.random()*3)]));}
  objects.sort((a,b)=>a.y-b.y);

  const input=new Input(); const camera=new Camera(VIEW_W,VIEW_H,WORLD_W,WORLD_H); const player=new Player(playerStart.x,playerStart.y,playerImg);
  let mouseWorld=null; let last=now(); let fps=0, frameCount=0, fpsTimer=0; let showColliders=false;

  toggleBtn.addEventListener('click',()=>{ showColliders=!showColliders; toggleBtn.textContent='Show Colliders: '+(showColliders?'On':'Off'); });
  resetBtn.addEventListener('click',()=>{ player.x=playerStart.x; player.y=playerStart.y; player.angle=0; });

  canvas.addEventListener('mousemove',e=>{ const r=canvas.getBoundingClientRect(); const mx=e.clientX-r.left; const my=e.clientY-r.top; mouseWorld={x:camera.x-camera.viewW/2+mx,y:camera.y-camera.viewH/2+my};});
  canvas.addEventListener('mouseleave',()=>{ mouseWorld=null;});

  window.addEventListener('dragover',e=>e.preventDefault());
  window.addEventListener('drop',e=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(!f)return; if(!f.type.startsWith('image/')) return alert('Drop an image file.'); const url=URL.createObjectURL(f); player.img.src=url; alert('Player sprite updated for this session.');});

  // Preloader
  (function preload(){
    const total=assets.length; let loaded=0; const maxWait=4000; let finished=false;
    const progressBar=document.getElementById('progressBar'), progressText=document.getElementById('progressText');
    function updateProgress(){ const pct=Math.round((loaded/total)*100); progressBar.style.width=pct+'%'; progressText.textContent=pct+'%';}
    function done(){ if(finished)return; finished=true; progressBar.style.width='100%'; progressText.textContent='100%'; setTimeout(()=>{ loading.classList.add('fade'); setTimeout(()=>{ loading.remove(); app.style.display='grid'; },420); last=now(); requestAnimationFrame(loop); },160);}
    assets.forEach(a=>{ if(a.type==='image'){ const img=new Image(); img.onload=()=>{ loaded++; updateProgress(); loaders[a.target]=img; if(a.target==='player') player.img=img; if(loaded===total) done(); }; img.onerror=()=>{ loaded++; updateProgress(); loaders[a.target]=img; if(a.target==='player') player.img=img; if(loaded===total) done(); }; img.src=a.src; } else { loaded++; updateProgress(); if(loaded===total) done(); }});
    if(total===0) done(); setTimeout(()=>{ if(!finished){ console.warn('Assets did not finish loading in time — continuing.'); done(); } },maxWait);
  })();

  // draw background
  function drawBackground(ctx,cam){ const left=Math.floor(cam.x-cam.viewW/2), top=Math.floor(cam.y-cam.viewH/2); ctx.fillStyle='#1b2b3a'; ctx.fillRect(0,0,cam.viewW,cam.viewH); const startX=Math.floor(left/TILE)*TILE, startY=Math.floor(top/TILE)*TILE; const endX=left+cam.viewW,endY=top+cam.viewH; for(let y=startY;y<=endY;y+=TILE){ for(let x=startX;x<=endX;x+=TILE){ if(x+TILE<0||x>WORLD_W||y+TILE<0||y>WORLD_H) continue; ctx.drawImage(tileCanvas,x-left,y-top); } } }

  function drawObjects(ctx,cam){ const left=cam.x-cam.viewW/2,top=cam.y-cam.viewH/2,right=left+cam.viewW,bottom=top+cam.viewH; for(let o of objects){ if(o.x+o.r<left||o.x-o.r>right||o.y+o.r<top||o.y-o.r>bottom) continue; o.draw(ctx,cam,showColliders);} }

  function drawCursor(ctx){ if(!mouseWorld)return; const p=camera.worldToScreen(mouseWorld.x,mouseWorld.y); ctx.save(); ctx.beginPath(); ctx.arc(p.sx,p.sy,6,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=1; ctx.stroke(); ctx.restore(); }

  function drawMinimap(){
    mmCtx.save(); mmCtx.setTransform(1,0,0,1,0,0); mmCtx.clearRect(0,0,minimap.width,minimap.height); 
    const pad=12, contentW=minimap.width-pad*2, contentH=minimap.height-pad*2; 
    const scale=Math.min(contentW/WORLD_W,contentH/WORLD_H); 
    const offsetX=pad, offsetY=pad; mmCtx.fillStyle='rgba(10,18,28,0.95)'; mmCtx.fillRect(0,0,minimap.width,minimap.height);
    // world objects
    for(let o of objects){ const px=offsetX+o.x*scale, py=offsetY+o.y*scale; mmCtx.fillStyle=o.type==='tree'?'#06d6a0':o.type==='crate'?'#8b5a0':'#999'; mmCtx.beginPath(); mmCtx.arc(px,py,Math.max(2,o.r*scale*0.6),0,Math.PI*2); mmCtx.fill(); }
    // camera viewport rectangle
    const camW=VIEW_W*scale, camH=VIEW_H*scale; const camX=offsetX+(camera.x-cam.viewW/2)*scale, camY=offsetY+(camera.y-cam.viewH/2)*scale;
    mmCtx.strokeStyle='rgba(255,255,255,0.32)'; mmCtx.lineWidth=2; mmCtx.strokeRect(camX,camY,camW,camH);
    // player
    const px=offsetX+player.x*scale, py=offsetY+player.y*scale, pr=8;
    mmCtx.save(); mmCtx.translate(px,py); mmCtx.rotate(player.angle); mmCtx.fillStyle='#ffd166'; mmCtx.beginPath();
    mmCtx.moveTo(0,-pr*1.5); mmCtx.lineTo(pr,pr); mmCtx.lineTo(-pr,pr); mmCtx.closePath(); mmCtx.fill(); mmCtx.restore();
    mmCtx.restore();
  }

  function loop(){
    const nowT=now(); let dt=(nowT-last)/1000; last=nowT;
    fpsTimer+=dt; frameCount++; if(fpsTimer>=1){ fps=frameCount; frameCount=0; fpsTimer=0;}
    player.move(dt,input); player.clampToWorld(WORLD_W,WORLD_H); player.resolveCollisions(objects); if(mouseWorld) player.angle=Math.atan2(mouseWorld.y-player.y, mouseWorld.x-player.x);
    camera.follow(player.x,player.y);

    // DRAW
    drawBackground(ctx,camera);
    drawObjects(ctx,camera);
    player.draw(ctx,camera,showColliders);
    drawCursor(ctx);
    drawMinimap();

    // update UI
    staminaBar.style.width=(player.stamina/STAMINA_MAX*100)+'%';
    status.textContent=`Pos: (${Math.round(player.x)},${Math.round(player.y)}) | FPS: ${fps}`;

    requestAnimationFrame(loop);
  }
})();
</script>
</body>
</html>
