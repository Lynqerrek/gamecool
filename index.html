<!--
Top-down 2D HTML game
Game title: Hide and Gun

Place this file in your GitHub repo (branch: main) as index.html
Add your player sprite as: ./Player.png (same folder as this file)
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hide and Gun</title>
  <style>
    html,body{height:100%;margin:0;background:#0e1724;color:#ddd;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
    #game-container{display:flex;flex-direction:column;align-items:center;gap:8px;padding:12px}
    canvas{background:#1b2b3a;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    #loading{
      position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
      background:#0e1724;color:#fff;font-size:36px;z-index:999;transition:opacity 0.6s ease;
    }
    #loading.fade-out{opacity:0;pointer-events:none;}
  </style>
</head>
<body>
  <div id="loading">
    <div style="font-size:64px;font-weight:700;margin-bottom:10px;letter-spacing:1px;">Hide and Gun</div>
    <div style="font-size:20px;opacity:0.7;">Loading...</div>
  </div>

  <div id="game-container" style="display:none;">
    <div style="width:100%;max-width:900px;text-align:center;padding:6px 0;font-size:14px;">
      Use <strong>W A S D</strong> to move — Player faces the mouse cursor — Camera centered
    </div>
    <canvas id="game" width="900" height="600"></canvas>
  </div>

<script>
// Utility functions
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function lerp(a,b,t){return a+(b-a)*t;}

// Input handler (WASD)
class InputHandler{
  constructor(){
    this.keys=new Set();
    window.addEventListener('keydown', e=>{
      const k=this._n(e.key);
      if(k){ this.keys.add(k); e.preventDefault?.(); }
    }, {passive:false});
    window.addEventListener('keyup', e=>{
      const k=this._n(e.key);
      if(k) this.keys.delete(k);
    });
  }
  _n(k){ if(!k) return null; k=k.toLowerCase(); if(k==='w') return 'up'; if(k==='a') return 'left'; if(k==='s') return 'down'; if(k==='d') return 'right'; return null; }
  isDown(k){ return this.keys.has(k); }
}

// Camera that centers on player
class Camera{
  constructor(viewW, viewH, worldW, worldH){
    this.viewW = viewW; this.viewH = viewH;
    this.worldW = worldW; this.worldH = worldH;
    this.x = viewW/2; this.y = viewH/2;
  }
  follow(tx, ty){
    const halfW = this.viewW/2, halfH = this.viewH/2;
    const desiredX = clamp(tx, halfW, this.worldW - halfW);
    const desiredY = clamp(ty, halfH, this.worldH - halfH);
    this.x = desiredX; this.y = desiredY; // instant center
  }
  worldToScreen(wx, wy){
    return { sx: wx - (this.x - this.viewW/2), sy: wy - (this.y - this.viewH/2) };
  }
}

// Player class
class Player{
  constructor(x,y,img){
    this.x = x; this.y = y;
    this.image = img;
    this.speed = 220; // px/sec
    this.angle = 0;
    this.w = 48; this.h = 48;
  }
  update(dt, input, world, mouse){
    let dx = 0, dy = 0;
    if(input.isDown('up')) dy -= 1;
    if(input.isDown('down')) dy += 1;
    if(input.isDown('left')) dx -= 1;
    if(input.isDown('right')) dx += 1;
    if(dx !== 0 || dy !== 0){
      const len = Math.hypot(dx,dy);
      dx /= len; dy /= len;
      this.x += dx * this.speed * dt;
      this.y += dy * this.speed * dt;
    }
    if(mouse) this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
    this.x = clamp(this.x, 0, world.width);
    this.y = clamp(this.y, 0, world.height);
  }
  draw(ctx, cam){
    const {sx, sy} = cam.worldToScreen(this.x, this.y);
    ctx.save();
    ctx.translate(sx, sy);
    ctx.rotate(this.angle + Math.PI/2);
    if(this.image && this.image.complete) ctx.drawImage(this.image, -this.w/2, -this.h/2, this.w, this.h);
    else { ctx.fillStyle = '#ffd166'; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
  }
}

// Simple world object for reference
class WorldObject{
  constructor(x,y,type){ this.x=x; this.y=y; this.type=type; }
  draw(ctx, cam){
    const {sx, sy} = cam.worldToScreen(this.x, this.y);
    ctx.save(); ctx.translate(sx, sy);
    if(this.type === 'tree'){
      ctx.fillStyle = '#6b3e16'; ctx.fillRect(-6,6,12,18);
      ctx.beginPath(); ctx.fillStyle = '#228b22'; ctx.ellipse(0,-2,18,14,0,0,Math.PI*2); ctx.fill();
    } else if(this.type === 'crate'){
      ctx.fillStyle = '#8b5a2b'; ctx.fillRect(-16,-12,32,24);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.strokeRect(-16,-12,32,24);
    } else {
      ctx.beginPath(); ctx.fillStyle = '#9aa0a6'; ctx.ellipse(0,0,18,12,0,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
}

// Core Game
class Game{
  constructor(canvas, viewW, viewH){
    this.canvas = canvas; this.ctx = canvas.getContext('2d');
    this.viewW = viewW; this.viewH = viewH;
    this.input = new InputHandler();
    this.world = { width: 2400, height: 1600 };
    this.cam = new Camera(viewW, viewH, this.world.width, this.world.height);

    this.playerImg = new Image();
    this.playerImg.src = './Player.png'; // <--- player image file name

    this.player = new Player(this.world.width/2, this.world.height/2, this.playerImg);

    this.objects = [];
    for(let i=0;i<25;i++){
      this.objects.push(new WorldObject(Math.random()*this.world.width, Math.random()*this.world.height, ['tree','crate','rock'][Math.floor(Math.random()*3)]));
    }

    this.mouse = null;
    this.last = performance.now();
    this._bind();
    requestAnimationFrame(this.loop.bind(this));
  }

  _bind(){
    this.canvas.addEventListener('mousemove', e=>{
      const rect = this.canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const wx = this.cam.x - this.cam.viewW/2 + mx;
      const wy = this.cam.y - this.cam.viewH/2 + my;
      this.mouse = { x: wx, y: wy };
    });
    this.canvas.addEventListener('mouseleave', ()=>{ this.mouse = null; });
  }

  loop(now){
    const dt = Math.min(0.05, (now - this.last) / 1000);
    this.last = now;
    this.player.update(dt, this.input, this.world, this.mouse);
    this.cam.follow(this.player.x, this.player.y); // instant center
    this.render();
    requestAnimationFrame(this.loop.bind(this));
  }

  render(){
    const ctx = this.ctx;
    ctx.clearRect(0,0,this.canvas.width, this.canvas.height);
    this._drawBackground(ctx);
    this._drawObjects(ctx);
    this.player.draw(ctx, this.cam);
    this._drawCursorMarker(ctx);
    this._drawUI(ctx);
  }

  _drawBackground(ctx){
    const tile = 64;
    const startX = Math.floor((this.cam.x - this.cam.viewW/2) / tile) * tile;
    const startY = Math.floor((this.cam.y - this.cam.viewH/2) / tile) * tile;
    for(let y = startY - tile; y < this.cam.y + this.cam.viewH/2 + tile; y += tile){
      for(let x = startX - tile; x < this.cam.x + this.cam.viewW/2 + tile; x += tile){
        if(x < 0 || x >= this.world.width || y < 0 || y >= this.world.height) continue;
        const {sx, sy} = this.cam.worldToScreen(x, y);
        ctx.fillStyle = ((Math.floor(x/tile)+Math.floor(y/tile))%2 === 0) ? 'rgba(30,45,65,0.7)' : 'rgba(28,40,58,0.7)';
        ctx.fillRect(sx, sy, tile-1, tile-1);
      }
    }
  }

  _drawObjects(ctx){
    const sorted = this.objects.slice().sort((a,b) => a.y - b.y);
    for(const o of sorted) o.draw(ctx, this.cam);
  }

  _drawCursorMarker(ctx){
    if(!this.mouse) return;
    const {sx, sy} = this.cam.worldToScreen(this.mouse.x, this.mouse.y);
    ctx.save();
    ctx.beginPath(); ctx.arc(sx, sy, 6, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.restore();
  }

  _drawUI(ctx){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(8,8,340,80);
    ctx.fillStyle = '#fff'; ctx.font = '13px system-ui,Arial';
    ctx.fillText('Position: ' + Math.round(this.player.x) + ', ' + Math.round(this.player.y), 16, 28);
    ctx.fillText('Use W A S D to move. Player faces mouse cursor.', 16, 48);
    ctx.fillText('Player is centered by camera. Player image: Player.png', 16, 66);
    ctx.restore();
  }
}

// Bootstrap
window.addEventListener('load', ()=>{
  const loading = document.getElementById('loading');
  const cont = document.getElementById('game-container');
  const c = document.getElementById('game');

  // HiDPI: use CSS size as logical view size, scale backing store
  const dpr = window.devicePixelRatio || 1;
  const cssW = c.width, cssH = c.height;
  c.style.width = cssW + 'px'; c.style.height = cssH + 'px';
  c.width = Math.floor(cssW * dpr); c.height = Math.floor(cssH * dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const game = new Game(c, cssW, cssH);

  // remove loading when player image is ready
  const checkLoaded = setInterval(()=>{
    if(game.playerImg.complete){
      loading.classList.add('fade-out');
      setTimeout(()=>{ loading.remove(); cont.style.display='flex'; }, 600);
      clearInterval(checkLoaded);
    }
  }, 150);

  // drag & drop to replace player image in-session
  window.addEventListener('dragover', e=>e.preventDefault());
  window.addEventListener('drop', e=>{
    e.preventDefault();
    const f = e.dataTransfer.files?.[0];
    if(!f) return;
    if(!f.type.startsWith('image/')) return alert('Drop an image file.');
    const url = URL.createObjectURL(f);
    game.playerImg.src = url;
    alert('Player sprite updated for this session. Commit your Player.png into the repo to make it permanent.');
  });
});
</script>
</body>
</html>
