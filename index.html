<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hide and Gun</title>
<style>
  :root{--bg:#0e1724;--panel:#0f2432;--accent:#ffd166}
  html,body{height:100%;margin:0;background:var(--bg);color:#ddd;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  /* layout: minimap left, game right */
  #app{display:grid;grid-template-columns:320px 1fr;gap:12px;height:100vh;padding:12px;box-sizing:border-box}
  .panel{background:var(--panel);padding:10px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.4)}
  #minimap{width:100%;height:calc(100vh - 56px);border-radius:8px;display:block;background:#06111a}
  #gameWrap{display:flex;flex-direction:column;gap:12px;align-items:center}
  #gameCanvas{border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6);background:transparent;display:block}
  .toolbar{display:flex;justify-content:space-between;align-items:center;gap:8px;width:100%}
  button{background:#2b3b4a;color:#fff;border:0;padding:8px 12px;border-radius:6px;cursor:pointer}
  #loading{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;background:var(--bg);z-index:9999;color:#fff;font-weight:700;transition:opacity .45s}
  #loading.fade{opacity:0;pointer-events:none}
  .small{font-size:13px;color:rgba(255,255,255,0.75)}
  footer{position:fixed;right:12px;bottom:12px;color:rgba(255,255,255,0.06);font-size:11px}
  /* progress bar */
  .progress-wrap{width:420px;height:16px;background:rgba(255,255,255,0.06);border-radius:10px;overflow:hidden}
  .progress-bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#ffd966);border-radius:10px;transition:width .15s linear}
  .progress-text{font-size:13px;color:rgba(255,255,255,0.9);margin-top:6px}
  @media(max-width:900px){#app{grid-template-columns:1fr} #minimap{height:200px}}
</style>
</head>
<body>
  <div id="loading">
    <div style="font-size:54px;letter-spacing:1px;">Hide and Gun</div>
    <div class="small">Loading assets…</div>

    <div class="progress-wrap" aria-hidden="false">
      <div id="progressBar" class="progress-bar"></div>
    </div>
    <div id="progressText" class="progress-text">0%</div>
    <div class="small" style="opacity:0.85">If loading stalls, the game will continue after a few seconds.</div>
  </div>

  <div id="app" style="display:none;">
    <div class="panel" style="display:flex;flex-direction:column;gap:10px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small"><strong>Minimap</strong> — shows entire world</div>
        <div class="small">Player.png</div>
      </div>
      <canvas id="minimap" width="280" height="800"></canvas>
      <div class="small">Green = tree, Brown = crate, Grey = rock. Player arrow shows facing.</div>
    </div>

    <div id="gameWrap">
      <div class="toolbar panel" style="width:100%">
        <div class="small">Use <strong>W A S D</strong> — Player faces cursor — Camera centered</div>
        <div style="display:flex;gap:8px">
          <button id="toggleColliders">Show Colliders: Off</button>
          <button id="resetPlayer">Reset</button>
        </div>
      </div>

      <canvas id="gameCanvas" width="980" height="640"></canvas>

      <div class="panel" style="width:100%;max-width:980px">
        <div id="status" class="small">Pos: — | FPS: —</div>
        <div style="margin-top:8px;font-size:12px;color:rgba(255,255,255,0.7)">Drop an image onto the page to test a player sprite for this session.</div>
      </div>
    </div>
  </div>

  <footer>Hide and Gun — prototype</footer>

<script>
/* Upgraded loader + improvements:
   - Robust asset preloader with progress bar and timeout fallback
   - Keeps minimap left, collisions, fixed tiles, HiDPI
*/

(() => {
  // CONFIG
  const VIEW_W = 980, VIEW_H = 640;
  const WORLD_W = 2400, WORLD_H = 1600;
  const TILE = 64;

  // UTIL
  const clamp = (v,a,b) => v < a ? a : (v > b ? b : v);
  const now = () => performance.now();

  // INPUT
  class Input {
    constructor(){
      this.keys = new Set();
      window.addEventListener('keydown', e=>{
        const k = this._n(e.key);
        if(k){ this.keys.add(k); e.preventDefault?.(); }
      }, {passive:false});
      window.addEventListener('keyup', e=>{ const k=this._n(e.key); if(k) this.keys.delete(k); });
    }
    _n(k){ if(!k) return null; k=k.toLowerCase(); if(k==='w') return 'up'; if(k==='a') return 'left'; if(k==='s') return 'down'; if(k==='d') return 'right'; return null; }
    isDown(k){ return this.keys.has(k); }
  }

  // CAMERA
  class Camera {
    constructor(viewW, viewH, worldW, worldH){
      this.viewW=viewW; this.viewH=viewH; this.worldW=worldW; this.worldH=worldH;
      this.x=viewW/2; this.y=viewH/2;
    }
    follow(px,py){
      const hw = this.viewW/2, hh = this.viewH/2;
      this.x = clamp(px, hw, this.worldW - hw);
      this.y = clamp(py, hh, this.worldH - hh);
    }
    worldToScreen(wx,wy){ return { sx: wx - (this.x - this.viewW/2), sy: wy - (this.y - this.viewH/2) }; }
  }

  // PLAYER
  class Player {
    constructor(x,y,img){
      this.x=x; this.y=y; this.img=img; this.r=18; this.speed=220; this.angle=0; this.w=48; this.h=48;
    }
    move(dt, input){
      let dx=0, dy=0;
      if(input.isDown('up')) dy -= 1;
      if(input.isDown('down')) dy += 1;
      if(input.isDown('left')) dx -= 1;
      if(input.isDown('right')) dx += 1;
      if(dx || dy){
        const len = Math.hypot(dx,dy); dx = (dx/len) * this.speed * dt; dy = (dy/len) * this.speed * dt;
      }
      this.x += dx; this.y += dy;
    }
    resolveCollisions(objs){
      for(let i=0;i<objs.length;i++){
        const o = objs[i];
        const sx = this.x - o.x; const sy = this.y - o.y;
        const dist2 = sx*sx + sy*sy;
        const min = this.r + o.r; const min2 = min*min;
        if(dist2 < min2 && dist2 > 0.0001){
          const dist = Math.sqrt(dist2); const overlap = min - dist; const nx = sx/dist, ny = sy/dist;
          this.x += nx * overlap; this.y += ny * overlap;
        } else if(dist2 <= 0.0001){
          const a = Math.random()*Math.PI*2; this.x += Math.cos(a)*1; this.y += Math.sin(a)*1;
        }
      }
    }
    clampToWorld(w,h){ this.x = clamp(this.x, this.r, w - this.r); this.y = clamp(this.y, this.r, h - this.r); }
    draw(ctx, cam, showColliders){
      const p = cam.worldToScreen(this.x, this.y);
      ctx.save(); ctx.translate(p.sx, p.sy); ctx.rotate(this.angle + Math.PI/2);
      if(this.img && this.img.complete) ctx.drawImage(this.img, -this.w/2, -this.h/2, this.w, this.h);
      else { ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.fill(); }
      if(showColliders){ ctx.strokeStyle='rgba(255,0,0,0.6)'; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.stroke(); }
      ctx.restore();
    }
  }

  // WORLD OBJECT
  class WorldObj {
    constructor(x,y,type){ this.x=x; this.y=y; this.type=type; this.r = (type==='tree')?28: (type==='crate')?20:18; }
    draw(ctx, cam, showCol){
      const p = cam.worldToScreen(this.x, this.y);
      ctx.save(); ctx.translate(p.sx, p.sy);
      if(this.type==='tree'){
        ctx.fillStyle='#6b3e16'; ctx.fillRect(-6,6,12,18);
        ctx.beginPath(); ctx.fillStyle='#228b22'; ctx.ellipse(0,-2,24,18,0,0,Math.PI*2); ctx.fill();
      } else if(this.type==='crate'){
        ctx.fillStyle='#8b5a2b'; ctx.fillRect(-16,-12,32,24); ctx.strokeStyle='rgba(0,0,0,0.22)'; ctx.strokeRect(-16,-12,32,24);
      } else {
        ctx.beginPath(); ctx.fillStyle='#9aa0a6'; ctx.ellipse(0,0,18,12,0,0,Math.PI*2); ctx.fill();
      }
      if(showCol){ ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.stroke(); }
      ctx.restore();
    }
  }

  // DOM
  const loading = document.getElementById('loading');
  const app = document.getElementById('app');
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const minimap = document.getElementById('minimap');
  const mmCtx = minimap.getContext('2d');
  const toggleBtn = document.getElementById('toggleColliders');
  const resetBtn = document.getElementById('resetPlayer');
  const status = document.getElementById('status');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');

  // HiDPI scaling
  const dpr = window.devicePixelRatio || 1;
  const cssW = canvas.width = VIEW_W, cssH = canvas.height = VIEW_H;
  canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
  canvas.width = Math.floor(cssW * dpr); canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  const mmCssW = minimap.width = 280;
  const mmCssH = Math.max(300, Math.min(window.innerHeight - 56, 800));
  minimap.style.height = mmCssH + 'px';
  minimap.style.width = mmCssW + 'px';
  minimap.width = Math.floor(mmCssW * dpr);
  minimap.height = Math.floor(mmCssH * dpr);
  mmCtx.setTransform(dpr,0,0,dpr,0,0);

  // ASSETS TO LOAD
  const assets = [
    { type: 'image', src: './Player.png', target: 'player' }
    // add more assets here if needed
  ];
  const loaders = {};
  // prepare placeholders
  let playerImg = new Image();
  loaders.player = playerImg;

  // pre-create tile canvas used by background (no external asset)
  const tileCanvas = document.createElement('canvas');
  tileCanvas.width = TILE; tileCanvas.height = TILE;
  const tctx = tileCanvas.getContext('2d');
  tctx.fillStyle = 'rgba(30,45,65,0.85)'; tctx.fillRect(0,0,TILE,TILE);
  tctx.fillStyle = 'rgba(28,40,58,0.85)'; tctx.fillRect(0,0,TILE/2,TILE/2); tctx.fillRect(TILE/2,TILE/2,TILE/2,TILE/2);

  // create objects once and sort by y
  const objects = [];
  const playerStart = { x: WORLD_W/2, y: WORLD_H/2 };
  for(let i=0;i<45;i++){
    let x,y,tries=0;
    do { x = Math.random()*WORLD_W; y = Math.random()*WORLD_H; tries++; } while(Math.hypot(x-playerStart.x,y-playerStart.y) < 180 && tries<40);
    objects.push(new WorldObj(x,y, ['tree','crate','rock'][Math.floor(Math.random()*3)]));
  }
  objects.sort((a,b)=>a.y - b.y);

  // instances
  const input = new Input();
  const camera = new Camera(VIEW_W, VIEW_H, WORLD_W, WORLD_H);
  const player = new Player(playerStart.x, playerStart.y, playerImg);

  // state
  let mouseWorld = null;
  let last = now();
  let fps = 0, frameCount = 0, fpsTimer = 0;
  let showColliders = false;

  toggleBtn.addEventListener('click', ()=>{
    showColliders = !showColliders;
    toggleBtn.textContent = 'Show Colliders: ' + (showColliders ? 'On' : 'Off');
  });
  resetBtn.addEventListener('click', ()=>{ player.x = playerStart.x; player.y = playerStart.y; player.angle = 0; });

  // mouse world coords for player facing
  canvas.addEventListener('mousemove', e=>{
    const r = canvas.getBoundingClientRect();
    const mx = (e.clientX - r.left);
    const my = (e.clientY - r.top);
    mouseWorld = { x: camera.x - camera.viewW/2 + mx, y: camera.y - camera.viewH/2 + my };
  });
  canvas.addEventListener('mouseleave', ()=>{ mouseWorld = null; });

  // drag & drop for session sprite replacement
  window.addEventListener('dragover', e=>e.preventDefault());
  window.addEventListener('drop', e=>{
    e.preventDefault();
    const f = e.dataTransfer.files?.[0];
    if(!f) return;
    if(!f.type.startsWith('image/')) return alert('Drop an image file.');
    const url = URL.createObjectURL(f);
    player.img.src = url;
    alert('Player sprite updated for this session. Commit Player.png to the repo to keep it.');
  });

  // Robust preloader
  (function preload() {
    const total = assets.length;
    let loaded = 0;
    const maxWait = 4000; // fail-safe: continue after 4s
    let finished = false;

    function updateProgress() {
      const pct = Math.round((loaded / total) * 100);
      progressBar.style.width = pct + '%';
      progressText.textContent = pct + '%';
    }

    function done() {
      if(finished) return;
      finished = true;
      progressBar.style.width = '100%';
      progressText.textContent = '100%';
      setTimeout(()=> {
        loading.classList.add('fade');
        setTimeout(()=>{ loading.remove(); app.style.display = 'grid'; }, 420);
      }, 160);
      // start main loop after a short delay so UI shows
      last = now();
      requestAnimationFrame(loop);
    }

    // handle each asset
    assets.forEach(a=>{
      if(a.type === 'image'){
        const img = new Image();
        img.onload = () => { loaded++; updateProgress(); loaders[a.target] = img; if(a.target === 'player'){ player.img = img; } if(loaded === total) done(); };
        img.onerror = () => { console.warn('Failed to load', a.src); loaded++; updateProgress(); loaders[a.target] = img; if(a.target === 'player') player.img = img; if(loaded === total) done(); };
        // start loading
        img.src = a.src;
      } else {
        // other asset types could be handled here
        loaded++; updateProgress();
        if(loaded === total) done();
      }
    });

    // if zero assets, finish immediately
    if(total === 0) done();

    // fail-safe timeout
    setTimeout(()=> {
      if(!finished) {
        console.warn('Assets did not finish loading in time — continuing.');
        done();
      }
    }, maxWait);
  })();

  // background tile canvas created earlier (tileCanvas)
  const patternCanvas = tileCanvas; // use same name for clarity

  // helper: draw background aligned to world (no seams)
  function drawBackground(ctx, cam){
    const left = Math.floor(cam.x - cam.viewW/2);
    const top = Math.floor(cam.y - cam.viewH/2);
    ctx.fillStyle = '#1b2b3a';
    ctx.fillRect(0,0,cam.viewW, cam.viewH);

    const startX = Math.floor(left / TILE) * TILE;
    const startY = Math.floor(top / TILE) * TILE;
    const endX = left + cam.viewW;
    const endY = top + cam.viewH;

    for(let y = startY; y <= endY; y += TILE){
      for(let x = startX; x <= endX; x += TILE){
        if(x + TILE < 0 || x > WORLD_W || y + TILE < 0 || y > WORLD_H) continue;
        const screenX = x - left;
        const screenY = y - top;
        ctx.drawImage(patternCanvas, Math.round(screenX), Math.round(screenY));
      }
    }
  }

  // draw objects (cull by viewport)
  function drawObjects(ctx, cam){
    const left = cam.x - cam.viewW/2, top = cam.y - cam.viewH/2, right = left + cam.viewW, bottom = top + cam.viewH;
    for(let i=0;i<objects.length;i++){
      const o = objects[i];
      if(o.x + o.r < left || o.x - o.r > right || o.y + o.r < top || o.y - o.r > bottom) continue;
      o.draw(ctx, cam, showColliders);
    }
  }

  // minimap draws entire world scaled and centered inside minimap canvas
  function drawMinimap(){
    mmCtx.save();
    mmCtx.setTransform(1,0,0,1,0,0); // neutral transform to draw in device independent pixels
    mmCtx.clearRect(0,0,minimap.width, minimap.height);
    mmCtx.fillStyle = '#06111a';
    mmCtx.fillRect(0,0,minimap.width, minimap.height);

    const pad = 12 * (window.devicePixelRatio || 1);
    const contentW = minimap.width - pad*2, contentH = minimap.height - pad*2;
    const scale = Math.min(contentW / WORLD_W, contentH / WORLD_H);
    const drawW = WORLD_W * scale, drawH = WORLD_H * scale;
    const offsetX = (minimap.width - drawW) / 2;
    const offsetY = (minimap.height - drawH) / 2;

    // draw objects
    for(let i=0;i<objects.length;i++){
      const o = objects[i];
      const ox = offsetX + o.x * scale;
      const oy = offsetY + o.y * scale;
      if(o.type === 'tree') mmCtx.fillStyle = '#2ea02e';
      else if(o.type === 'crate') mmCtx.fillStyle = '#8b5a2b';
      else mmCtx.fillStyle = '#9aa0a6';
      const rr = Math.max(1, Math.round(o.r * scale));
      mmCtx.beginPath(); mmCtx.arc(ox, oy, rr, 0, Math.PI*2); mmCtx.fill();
    }

    // draw player (triangle rotated)
    const px = offsetX + player.x * scale;
    const py = offsetY + player.y * scale;
    const pr = Math.max(3, Math.round(player.r * scale));
    mmCtx.save();
    mmCtx.translate(px, py);
    mmCtx.rotate(player.angle);
    mmCtx.fillStyle = '#ffd166';
    mmCtx.beginPath();
    mmCtx.moveTo(0, -pr*1.6);
    mmCtx.lineTo(pr, pr);
    mmCtx.lineTo(-pr, pr);
    mmCtx.closePath();
    mmCtx.fill();
    mmCtx.restore();

    // draw camera viewport rectangle on minimap (optional)
    const camLeft = offsetX + (camera.x - camera.viewW/2) * scale;
    const camTop = offsetY + (camera.y - camera.viewH/2) * scale;
    const camW = camera.viewW * scale;
    const camH = camera.viewH * scale;
    mmCtx.strokeStyle = 'rgba(255,255,255,0.06)';
    mmCtx.lineWidth = Math.max(1, 1 * (window.devicePixelRatio || 1));
    mmCtx.strokeRect(camLeft, camTop, camW, camH);

    // border
    mmCtx.strokeStyle = 'rgba(255,255,255,0.06)';
    mmCtx.strokeRect(offsetX - 1, offsetY - 1, drawW + 2, drawH + 2);

    mmCtx.restore();
  }

  // draw cursor marker
  function drawCursor(ctx){
    if(!mouseWorld) return;
    const p = camera.worldToScreen(mouseWorld.x, mouseWorld.y);
    ctx.save();
    ctx.beginPath(); ctx.arc(p.sx, p.sy, 6, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.12)'; ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=1; ctx.stroke(); ctx.restore();
  }

  // main loop
  function loop(ts){
    const t = ts || now();
    let dt = (t - last) / 1000;
    if(dt > 0.05) dt = 0.05;
    last = t;

    // update
    player.move(dt, input);
    player.resolveCollisions(objects);
    player.clampToWorld(WORLD_W, WORLD_H);
    if(mouseWorld) player.angle = Math.atan2(mouseWorld.y - player.y, mouseWorld.x - player.x);
    camera.follow(player.x, player.y);

    // render
    // clear canvas (logical size)
    ctx.clearRect(0,0,canvas.width, canvas.height);

    drawBackground(ctx, camera);
    drawObjects(ctx, camera);
    player.draw(ctx, camera, showColliders);
    drawCursor(ctx);

    frameCount++; fpsTimer += dt;
    if(fpsTimer >= 0.4){ fps = Math.round(frameCount / fpsTimer); frameCount = 0; fpsTimer = 0; }
    status.textContent = `Pos: ${Math.round(player.x)} , ${Math.round(player.y)} | FPS: ${fps}`;

    // minimap always visible
    drawMinimap();

    requestAnimationFrame(loop);
  }

  // mouse world conversion
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left);
    const my = (e.clientY - rect.top);
    mouseWorld = { x: camera.x - camera.viewW/2 + mx, y: camera.y - camera.viewH/2 + my };
  });
  canvas.addEventListener('mouseleave', ()=>{ mouseWorld = null; });

  // begin after preload's done (preload triggers loop)
  // Note: preload() calls requestAnimationFrame(loop) after done

  // small initial values
  last = now();

})(); // IIFE end
</script>
</body>
</html>
